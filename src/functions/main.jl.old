useData(df::String) = DataFrame(File(df))
useData(df::DataFrame) = df
useData() = nothing

struct options
    data
end

struct inits
    data
end


function sfopt(;kwargs...)
    # opt = (:warmstart_solver, :warmstart_maxIT, :main_solver, :main_maxIT, :tolerance,
    #        :verbose, :banner, :ineff_index, :marginal, :table_format)
    default = OrderedDict(:warmstart_solver=>NelderMead(), :warmstart_maxIT=>100,
                          :main_solver=>Newton(), :main_maxIT=>2000, :tolerance=>1e-8,
                          :verbose=>false)
    length(kwargs) == 0 || setindex!(default, values(values(kwargs)), keys(kwargs))
    return options(values(default))
end


function sfinit(startpt)
    return inits(startpt)
end


function sfmodel_fit(struc::SFmodel, data::AbstractData, args...)
    #=  get the MLE options and initial value if any  =#
    if length(args) == 0
        opt, startpt = sfopt(), ones(data.ψ[end])
    elseif length(args) == 1
        tar = args[1]
        isa(tar, options) &&  (opt = tar.data; startpt = ones(data.ψ[end]))
        isa(tar, inits) && (opt = sfopt(); startpt = tar.data)
    else
        isa(args[1], options) && (opt = args[1].data; startpt = args[2].data)
        isa(args[1], inits) && (opt = args[2].data; startpt = args[1].data)
        length(startpt) != data.Ψ[end] && throw("the length of the initializer doesn't match the
                                                  length of parameters, please check the type")
    end


    #=  MLE maximization process  =#
    param = MLE(struc, data, opt, startpt)

    #=  output table  =#
    #=  calculate the jlms/bc index  =#
    return result(param)
end


#=  output the result after the model fitting process  =#
struct result
    param::Vector
end

